# Что это

Инструмент, который пытается упростить разработку приложений на Node.js, которые состоят из нескольких пакетов.

# Это что, lerna?

Не совсем, хотя и решает похожую задачу.
В отличие от lerna, этот инструмент не пытается создавать ссылки на общие зависимости или выводить их на уровень директории выше, как делает lerna.
Цель norman -- воссоздать в окружении разработчика структуру node_modules, которая максимально соответствует той, которая будет в продакшене.
Для этого он сихронизирует содержимое пакетов, копируя файлы и выступая в качестве локального npm-репозитория.

# Чем плох `npm link`?

1. `npm link` по умолчанию создает глобальную ссылку на пакет.
  То есть, если необходимо иметь несколько версий одного модуля, то использовать его с помощью `npm link` довольно сложно.
2. Модуль `B`, который был прилинкован в модуль `A`, может иметь свою директорию `node_modules`.
  Если, при этом и у модуля `A`, и у модуля `B` есть общая зависомость `C` совместимых версий (которая при обычной установке была бы вынесена на верхний уровень), эти модули будут импортировать разные копии модуля `C`.
  В большинстве случаев это работает, но не всегда, и может приводить к труднообнаружимым багам.
3. Содержимое директории после установки из npm-репозитория, как правило, отличается от того, что находится в директории с исходниками на машине разработчика.
  Из-за этого также может возникать ряд проблем.
  Например, ts-loader отказывается собирать код, если рядом с импортируемым `.js` файлом находится `.ts` файл.
  
# Что делает norman?

norman пытается воспроизвести то, что получается после сборки модуля, его опубликования в npm-репозиторий и установки.
Это не всегда возможно.
Но он пытается.

# Как начать?

1. Установить: `npm i -g node-norman`
2. Создать файл `norman.json`, который перечисляет пакеты, которые мы будет разрабатывать (формат см. ниже)
3. Запустить `norman fetch` в директории, где находится `norman.json` (или указать путь явно: `norman --config ~/project/.norman.json fetch`).
4. Теперь norman склонирует модули с помощью git и установит их зависимости с помошью `npm install`.

После этого можно начинать работать.
Чтобы синхронизировать все модули в проекте между собой, достаточно запустить `norman sync-all` в директории с `norman.json` или в любой дочерней директории.
Можно синхронизировать только один модуль из проекта: `norman sync my-module`.
`my-module` -- это имя модуля, которое указано в его `package.json`.

Перед тем, как синхронизировать модули, norman запускает команды для сборки, которые указаны в файле `norman.json`.

# Файл `.norman.json`

`modulesDirectory` (string, required): все модули в проекте будут клонироваться в указанную директорию.
Если путь относительный, то он отсчитывается от директории, где находится конфиг.

`includeModules` (string or string[]): путь к другому конфигу `norman.json` (может быть относительным по отношению к директории текущего конфига).
Модули из этого конфига будут включены в текущий проект.

`defaultBranch`, `defaultBuildTriggers`, `defaultIgnoreScope`, `defaultNpmIgnore`, `defaultBuildCommands` -- значения соответстующих параметров для всех модулей в проекте, где эти параметры не указаны.

`modules`: список модулей в проекте.
Значение должно быть массивом объектов, где каждый объект имеет следующие свойства:

`module.repository` (string, required): URL репозитория.

`module.branch` (string): ветка git, которую нужно использовать для клонирования модуля.
Дефолт -- `master`.

`module.path` (string): явно указывает путь к директории, куда будет клонироваться модуль.
Путь может быть относительным по отношению к директории проекта.

`module.ignoreScope` (boolean): если `false`, то модуль `@myscope/repo` будет клонироваться в директорию `repo`, если `true` -- то в `myscope/repo` 
Дефолт -- `false`.

`module.name` (string): имя модуля.
По умолчанию, это имя будет получено из `package.json` после клонирования модуля.

`module.npmIgnore` (string): указывает путь к файлу `.npmignore`, который по умолчанию будет использоваться для тех модулей, где нет своего файла `.npmignore`.
Путь может быть относительным директории главного проекта.
Дефолт -- не определено.

`module.buildTriggers` (string[]): список масок для файлов (используется minimatch).
Пересборка модуля будет запускаться только в том случае, если в модуле изменился хотя бы один из файлов, подпадающих под одну из указанных здесь масок.

`module.buildCommands` (string[]): список команд для сборки модуля.
Каждая строка в массиве -- это либо имя npm-скрипта, либо shell-команда.
Перед запуском проверяется, есть ли в `package.json` команда с таким именем.

`module.useNpm` (boolean): если `false`, то модуль не будет синхронизироваться и не будет попыток управлять его зависимостями.
По умолчанию `true`.

## Поддержка source map

Когда файлы синхронизируются в модуль без локфайла, norman умеет автоматически изменять source map так, чтобы сохранить ссылки на оригинальные исходные файлы.

## Обновление зависимостей

Norman может помочь при обновлении зависимостей модулей.
Чтобы показать неактуальные зависимости всех модулей проекта, запустите `norman outdated`.
Чтобы обновить все зависимости всех модулей до версий, которые удовлетворяют указанным в `package.json` диапазонам версий, запустите `norman outdated --upgrade`.
Чтобы обновить все зависимости всех модулей до самых новых версий, перезаписав диапазоны версий, запустите `norman outdated --upgrade --hard` (осторожно, все может сломаться).

По умолчанию `norman outdated` не анализирует зависимости модулей, которые подключены из других проектов через `includeModules`.
Чтобы анализировать все модули, используйте флаг `--with-included`.

# Пример конфигурации

```json
{
  "modulesDirectory": "/home/user/development/myproject",
  "defaultBuildTriggers": [ "*.ts", "tsconfig.json", "package.json", "webpack.config.js" ],
  "modules": [
    {
      "repository": "git@github.com:zenwarr/norman.git",
      "branch": "alpha"
    }
  ]
}
```

# Решение проблем

Norman использует локальный npm-сервер.
Поскольку при переустановке зависимостей, когда версия зависимости не изменилась `npm` будет пытаться не делать запроса к репозиторию и устанавливать модуль из локального кеша, norman приходится инвалидировать кеш перед установкой зависимостей.
По этой причине необходимо, чтобы текущий пользователь имел достаточно прав, чтобы выполнить команду `npm cache clean`.

Кроме того, чтобы после каждой инвалидации кеша `npm` не приходилось загружать модули из реального реестра, norman управляет собственным кешем зависимостей, загруженных с других репозиториев.
Чтобы очистить этот кеш, можно использовать команду `norman clean cache`.

Информация о состоянии исходных файлов модулей, которая используется для определения необходимости пересборки модулей, хранится в директории `~/.norman-state`.
Эти данные можно удалить командой `norman clean state`.

Чтобы удалить все, включая временные файлы, которые создаются при упаковке модулей, можно использовать команду `norman clean all`.
